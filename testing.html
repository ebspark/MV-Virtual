<!DOCTYPE html>
<html lang="en">
<head>
    <title>Three.js - Scrollable Scenes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background-color: #fff;
            font-family: Arial, sans-serif;
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2em 0;
        }

        .list-item {
            width: 300px;
            margin: 1em 0;
            padding: 1em;
            box-shadow: 1px 2px 4px 0px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f9f9f9;
            border-radius: 8px;
        }

        .list-item > div:nth-child(1) {
            width: 300px;
            height: 300px;
        }

        .list-item > div:nth-child(2) {
            margin-top: 0.5em;
            font-size: medium;
            color: #555;
        }

        #three-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
}

    </style>
</head>
<body>

<canvas id="three-canvas"></canvas>
<div id="container"></div>
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
    }
}
</script>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    
    let renderer, canvas;
    const scenes = [];
    const visibleScenes = new Set();

    init();

    function init() {
        canvas = document.getElementById('three-canvas');
        const container = document.getElementById('container');

        const geometries = [
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.SphereGeometry(0.5, 12, 8),
            new THREE.DodecahedronGeometry(0.5),
            new THREE.CylinderGeometry(0.5, 0.5, 1, 12)
        ];

        for (let i = 0; i < 20; i++) {
            const scene = new THREE.Scene();

            const element = document.createElement('div');
            element.className = 'list-item';

            const sceneElement = document.createElement('div');
            element.appendChild(sceneElement);

            const descriptionElement = document.createElement('div');
            descriptionElement.innerText = `Scene ${i + 1}`;
            element.appendChild(descriptionElement);

            container.appendChild(element);

            const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 10);
            camera.position.z = 2;
            scene.userData.camera = camera;

            const geometry = geometries[Math.floor(Math.random() * geometries.length)];
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(Math.random(), 1, 0.75),
                roughness: 0.5,
                metalness: 0
            });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            scene.add(new THREE.HemisphereLight(0xaaaaaa, 0x444444, 3));
            const light = new THREE.DirectionalLight(0xffffff, 1.5);
            light.position.set(1, 1, 1);
            scene.add(light);

            scene.userData.element = sceneElement;
            scenes.push(scene);
        }

        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0xffffff);
        renderer.setSize(window.innerWidth, window.innerHeight);

const observer = new IntersectionObserver(onVisibilityChange, {
    root: container,
    threshold: 0.25 // Adjust to suit your needs
});
        scenes.forEach(scene => observer.observe(scene.userData.element));

        window.addEventListener('resize', onWindowResize);
        renderer.setAnimationLoop(animate);
    }

    function onVisibilityChange(entries) {
        entries.forEach(entry => {
            const scene = scenes.find(scene => scene.userData.element === entry.target);
            if (entry.isIntersecting) {
                visibleScenes.add(scene);
            } else {
                visibleScenes.delete(scene);
            }
        });
    }

    function onWindowResize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function animate() {
    renderer.clear();

    visibleScenes.forEach(scene => {
        const element = scene.userData.element;
        const rect = element.getBoundingClientRect();
        const dpr = window.devicePixelRatio;
        const width = rect.width * dpr;
        const height = rect.height * dpr;
        const left = rect.left * dpr;
        const bottom = window.innerHeight * dpr - rect.bottom * dpr;

        // Skip rendering if the element is completely out of the viewport
        if (rect.bottom < 0 || rect.top > window.innerHeight || rect.right < 0 || rect.left > window.innerWidth) {
            return;
        }

        scene.userData.camera.aspect = rect.width / rect.height;
        scene.userData.camera.updateProjectionMatrix();

        renderer.setViewport(left, bottom, width, height);
        renderer.setScissor(left, bottom, width, height);
        renderer.setScissorTest(true);

        // Rotate the first child (assumed to be the mesh)
        if (scene.children[0]) {
            scene.children[0].rotation.y += 0.01;
        }

        renderer.render(scene, scene.userData.camera);
    });
}

</script>

</body>
</html>